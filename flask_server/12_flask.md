#### Flask

##### И pyhon

Для тех кто не в курсе немного википедии:

> Python - Высокоуровневый язык программирования общего назначения с динамической строгой  типизацией и автоматическим управлением памятью... и т.д.
>
> Flask - Фреймворк для  создания веб-приложений на языке программирования Python, использующий  набор инструментов Werkzeug, а также шаблонизатор Jinja2. Относится к  категории так называемых микрофреймворков - минималистичных каркасов  веб-приложений, сознательно предоставляющих лишь самые базовые  возможности.

В общем Flask, это то, во что мы обернем нашу Python программу для доступности ее из сети. Или правильнее, это каркас, на котором мы и построим нашу программу.



Давайте для начала проверим, вдруг на вашей ВМ не установлен python:

(А так вообще бывает?)

```bash
python3 -V
```

Если ответ будет: Python 3.x.xx - все в порядке, иначе его нужно установить:

```bash
sudo apt install python3
```

Так же нам понадобится менеджер пакетов:

```bash
sudo apt install python3-pip
```

Работает он по принципу **apt**, которым пользуемся для установки приложений на этом сервере, только внутри python. Синтаксис так же аналогичен. Не волнуйтесь, дальше все покажу.



Теперь нужно установить несколько инструментов для разработки:

(Точнее я уверен, что они уже стоят, но проверить это необходимо. Как я уже писал ранее, если пакет уже есть в системе - apt просто пропустит этот шаг.)

```bash
sudo apt install build-essential libssl-dev libffi-dev python3-dev python3-setuptools
```

Пояснение, я конечно дам, но можете не акцентировать на это внимания, нам они в дальнейшей работе так же как Werkzeug, и Jinja2 не пригодится. Точнее сами пакеты в системе конечно нужны, но мы их никак явным образом использовать не будем.

build-essential - информационный список пакетов необходимых для dpkg

libssl-dev - пакет для работы с SSL и TLS

libffi-dev - интерфейс чужеродных функций. Позволит вызывать функции написанные на других языках.

python-dev - содержит все необходимое для компиляции модулей расширения

setuptools – стандартный способ создавать пакеты в Python.



Ну и поскольку лучшей практикой считается запуск приложения в изолированном (виртуальном) окружении, то давайте так же установим его:

```bash
sudo apt install python3-venv
```

Проект будет располагаться в домашней директории. (/home/'имя пользователя'), поэтому переймем туда и создадим папку для него:

(Если используете МС - просто нажмите F7.)

```bash
mkdir blueoctopus
```

Обратите внимание, что мы работаем в своей директории, со своими стандартными полномочиями, поэтому `sudo` здесь не используется.

Зайдем в созданный каталог

```bash
cd blueoctopus
```

И создадим виртуальное окружение:

```bash
python3 -m venv octopusenv
```

Через ключ **-m** мы вызвали модуль **venv**, который создал для нас изолированное окружение с именем **octopusenv**

И при помощи системной команды **source** загрузим его переменные. (Активируем виртуальное окружение)

```bash
source blueoctopusenv/bin/activate
```

Обратите внимание на то как изменилось приглашение командной строки. Это означает, что мы "внутри" окружения для нашего проекта. Дальнейшую работу продолжим в нем.



На случай, если вам понадобится прерваться - отключить окружение можно командой:

```bash
deactivate
```

Только не забудьте его снова включить для продолжения настройки.



Для начала установим средство распаковки пакетов python:

```bash
pip install wheel
```



Дальше ставим Flask, и еще один элемент, без которого нам не обойтись:

```bash
pip install flask gunicorn
```

Обращаю внимание, что для двух предыдущих команд я воспользовался пакетным менеджером **pip**.

И так, gunicorn - 

> **WSGI** (расшифровывается как Web Server Gateway Interface — интерфейс шлюза Web-сервера) — **это** простой и универсальный интерфейс взаимодействия между Web-сервером и Web-приложением, впервые описанный в PEP-333 

кратко, это приложение, которое будет переводить запросы в читаемый вид от Nginx на Flask и обратно, в нашем случае он же и будет запускать код приложения, при чем в нескольких потоках.



В итоге, цепочка прохождения запроса будет выглядеть как то так: 

Интернет -> Nginx -> Gunicorn -> Flask + Python, и обратно.

Почти все необходимые элементы системы установлены, поэтому давайте попробуем настроить эту цепочку. Начнем, пожалуй с конца, а именно с простого Flask приложения.

Конечно писать код прямо так, на сервере не сама лучшая затея, лучше воспользоваться предназначенными для этого IDE средствами доставки, но  небольшой файлик-заглушку давайте сделаем.

```bash
nano main.py
```

И пишем следующий код:

```python
# Импортируем класс Flask из пакета flask
from flask import Flask, render_template

# Импортруем модуль для работы с json
import json

# Создадим объект Flask
# и передадим ему имя пакета в качестве аргумента 
app = Flask(__name__)


# Воспользуемся поставляемыми flask декораторами route 
# для создания двух адресов на нашем сервере
#
# Первый, это просто индексная страница, которая будет
# передана пользователю, когда он введет адрес нашего сервера
# в адресной строке. Мы ему вернем произвольный index.html
# и код 200 "OK"
@app.route('/', methods=['GET', 'HEAD',])
def hello_world():
    return render_template("index.html"), 200


# Второй маршрут будет отвечать за POST запрос по адресу:
# blueoctopus.cc/api2 и возвращать сформированный json 
# Метод GET и 'Content-Type' я добавил для обработки
# пустых запросов из браузера
@app.route('/api2', methods=['POST', 'GET',])
def api_json():
    json_response = {"server_status": 201, "description": "Hello from python",}
    return json.dumps(json_response, indent=2), 201, {'Content-Type':'application/json'}

# Это условие гарантирует, что указанный после ного код
# будет выполнентолько при запуске как основная программа.
# При вызове метода run при импорте он вызван не будет.
# Это важно, потому что gunicorn будет импортировать его.
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0') # 5000 port
```



Почти готово, остался index.html, которая  должна быть показана пользователю при обращении на главную страницу сайта. По умолчанию Flask будет искать его в папке **templates** своей директории.

Создадим ее:

```bash
mkdir templates
```

И средствами SSH можно скопировать в нее любой статичный index.html



Если уж совсем никак не найти вам такой, то:

```bash
nano templates/index.html
```

И вставьте в него код ниже, должно сработать.

```html
<!doctype html>
<html>
  <head>
    <title>Our Funky HTML Page</title>
    <meta name="description" content="Our first page">
    <meta name="keywords" content="html tutorial template">
  </head>
 
  <body>
    <div>
      Hello from Flask server    
    </div>
  </body>
</html>
```



По умолчаниюFlask использует, доступ к которому мы с вами уже открыли при настройке UFW,  поэтому просто запустим его:

```
python main.py
```

И если мы видим что то похожее на это:

```bash
 * Serving Flask app 'main' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 186-312-395
```

То мы все сделали правильно и наше приложение работает. Если сейчас открыть главную страницу нашего сайта, то мы увидим наш index.html, а перейдя в раздел /api2 - красиво отрисованный json ответ.

Думаю стоит сделать некоторое уточнение. Я тут при записи видео столкнулся с тем, что точно не помню как передать порт в адресной строке :)

1. Значит, мы запустили наше приложение в режиме отладки на 5000 порту, и соответственно обратится к серверу мы должны с его указанием. 

2. У нас нет еще настроенного сертификата шифрования, и поэтому во многих браузерах это нужно указать явно.

   

Запросы в адресной строке в моем случае буду выглядеть так:



http://blueoctopus.cc:5000 - Индексная страница, с генерацией стандартного HTML ответа

http://blueoctopus.cc:5000/api2 - Тест ответа  JSON



Перед завершением этой части, хочу обратить ваше внимание на предупреждение, которое написал нам сервер красными буквами. Способ, которым мы воспользовались может применяться только на этапе разработки, на рабочих серверах приложение должно использоваться через WSGI.

