#### Gunicorn

По сути, это еще один веб сервер. 

Где то выше я уже писал о предполагаемой схеме работы:

Когда Nginx решит, что запрос необходимо передать нашему Python приложению, то он его как раз направит на Gunicorn, который в свою очередь переведет его в понятный нашему приложению WSGI формат, запустит код нашего приложения,  передаст этот запрос туда, потом заберет результаты, и вернет их обратно Nginx. Который, в свою очередь передаст результаты пользователю.

Я не буду углубятся в тему, почему именно так, но скажу что каждый из этих серверов хорош именно в своем деле, и использования такой связки является хорошей практикой.



Если вы вышли из виртуального окружения нашего сервиса, то необходимо его опять активировать:

```bash
source octopusenv/bin/activate
```



Сейчас нам необходимо создать точку для входа или, если хотите, запуска  нашего приложения для Gunicorn. Это будет еще один маленький файл на языке Python:

```bash
nano wsgi.py
```

```python
# Импортируем наше приложение
from main import app

# И создадим параметр для запуска
# О значении данного условия я говорил выше.
if __name__ == "__main__":
    app.run()
# Обратите внимание, здесь команда без параметров,
# их мы передадим через командную строку
```

И конечно давайте запустим наш сервер приложения:

```bash
gunicorn --bind 0.0.0.0:5000 wsgi:app
```

Именно здесь мы передали хост и порт, которые должен "слушать" Guicorn. Мы ему как бы сказали: При поступлении запроса с любого интерфейса на 5000 порт запустить приложение app и передать его туда.

Если все сделано правильно, то зайдя по адресу нашего сервера мы так же должны увидеть страницу сгенерированную нашим приложением.

Все в порядке, остановим сервер -  ctrl+x  и закроем виртуальное окружение.

```bash
deactivate
```



Gunicorn установлен и работает, и сейчас мне бы хотелось просто сказать - а давайте "добавим его в автозагрузку", но все не так просто. Думаю, что правильнее будет - теперь необходимо дать возможность системным службам управлять его состоянием, в том числе и запускать при старте системы.

Инициализацией и управлением службами на нашем сервере занимается давно ставшая стандартом подсистема **systemd**, именно для нее мы писали команды начинающиеся на **systemctl**. 

Systemd запускает сервисы, которые описаны в его файлах конфигурации, которые называют **юниты**, расположены на в разных местах системы, в зависимости от метода установки. Нас интересует папка **/etc/systemd/system/**, куда помещают файлы созданные пользователем. (Ну хорошо, системным администратором).

Создадим такой файл:

```bash
sudo nano /etc/systemd/system/blueoctopusgu.service
```

Думаю, вас уже не удивит, если я скажу, что файл имеет такой синтаксис:

```
[Название секции]
имя_переменной = значение
```

Стандартный юнит должен содержать минимум три секции: [Unit], [Service], [Install], поэтому давайте их и опишем для нашего сервиса:

```bash
# Опишем что за сервис
[Unit]
# Описание
Description=Blueoctopus gunicorn instance
# Здесь мы говорим systemd запускать наш сервер только после загрузки сетевых служб. 
After network.target

# Уже описывает наш юнит для системы.
[Service]
# От чьего имени запускать сервис
# Это я
User=max
# Группа созданная для Nginx
Group=www-data
# Где его запускать
WorkingDirectory=/home/trash/blueoctopus
# Путь к виртуальному окружению, в котором его запускать
Envirovement="PATH=/home/trash/flaskproject/flaskenv/bin"
# Команда запуска сервиса с параметрами, о ней ниже
ExecStart=/home/trash/blueoctopus/blueoctopusenv/bin/gunicorn --workers 2 --bind unix:gunicorn.sock -m 007 wsgi:app

# Здесь опишем на каком уровне стартует наш сервис
[Install]
# Он будет соостветсвовать стандартному серверному (Runlevel 3)
# Многопользовательский режим с поддержкой сети, но без графического интерфейса.
WantedBy=multi-user.target
```

Команда запуска:

/home/trash/flaskproject/flaskenv/bin/gunicorn - Полный путь к исполняемому файлу.

--workers 2 - Количество процессов запускаемых сервером, я поставил два, по количеству ядер процессора на нашем сервере.

--bind unix:flaskproject.sock - поскольку все в Linux представляется как файлы, то и точку взаимодействия  между Nginx и gunicorn мы опишем как специальный тип файла .sock (Вообще через этот файл кто угодно может взаимодействовать с сервером приложений, но в нашем случает это будет именно Nginx).

-m 007 - маска прав доступа к создаваемому файлу написанная по стандарту umask. В данном случае дает полный доступ указанному пользователю и группе, и запрещает всем остальным (u=rwx,g=rwx,o=)

wsgi:app - ну и наконец код, который должен запустить gunicorn. Это приложение **app** импортированное в файле **wsgi.py**

> Надо бы еще написать команду для перезапуска сервиса, но возможно я это сделаю в следующей версии данной инструкции.



Команды управления стандартные для systemd:

Запустить:

```bash
sudo systemctl start blueoctopusgu
```

Посмотреть статус:

```bash
sudo systemctl status blueoctopusgu
```

И вот теперь мы добавим его в автозагрузку:

```bash
sudo systemctl enable blueoctopusgu
```



